

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>lyra.abstract_domains.assumption package &mdash; Lyra 0.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="Lyra 0.1 documentation" href="index.html"/>
        <link rel="up" title="lyra.abstract_domains package" href="lyra.abstract_domains.html"/>
        <link rel="next" title="lyra.abstract_domains.liveness package" href="lyra.abstract_domains.liveness.html"/>
        <link rel="prev" title="lyra.abstract_domains package" href="lyra.abstract_domains.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Lyra
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">lyra</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="lyra.html">lyra package</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="lyra.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l4 current"><a class="reference internal" href="lyra.abstract_domains.html">lyra.abstract_domains package</a></li>
<li class="toctree-l4"><a class="reference internal" href="lyra.core.html">lyra.core package</a></li>
<li class="toctree-l4"><a class="reference internal" href="lyra.engine.html">lyra.engine package</a></li>
<li class="toctree-l4"><a class="reference internal" href="lyra.frontend.html">lyra.frontend package</a></li>
<li class="toctree-l4"><a class="reference internal" href="lyra.semantics.html">lyra.semantics package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="lyra.html#module-lyra.main">Submodules</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Lyra</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
          <li><a href="modules.html">lyra</a> &raquo;</li>
      
          <li><a href="lyra.html">lyra package</a> &raquo;</li>
      
          <li><a href="lyra.abstract_domains.html">lyra.abstract_domains package</a> &raquo;</li>
      
    <li>lyra.abstract_domains.assumption package</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/lyra.abstract_domains.assumption.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-lyra.abstract_domains.assumption">
<span id="lyra-abstract-domains-assumption-package"></span><h1>lyra.abstract_domains.assumption package<a class="headerlink" href="#module-lyra.abstract_domains.assumption" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-lyra.abstract_domains.assumption.alphabet_domain">
<span id="submodules"></span><h2>Submodules<a class="headerlink" href="#module-lyra.abstract_domains.assumption.alphabet_domain" title="Permalink to this headline">¶</a></h2>
<div class="section" id="alphabet-abstract-domain">
<h3>Alphabet Abstract Domain<a class="headerlink" href="#alphabet-abstract-domain" title="Permalink to this headline">¶</a></h3>
<p>Non-relational abstract domain to be used for <strong>input data assumption analysis</strong>.
The set of possible string values of a program variable in a program state
is represented by the sets of characters that must and may form the string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body">Radwa Sherif Abdelbar and Caterina Urban</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="lyra.abstract_domains.assumption.alphabet_domain.AlphabetLattice">
<em class="property">class </em><code class="descclassname">lyra.abstract_domains.assumption.alphabet_domain.</code><code class="descname">AlphabetLattice</code><span class="sig-paren">(</span><em>certainly: typing.Set[str] = set()</em>, <em>maybe: typing.Set[str] = {‘&amp;’</em>, <em>‘8’</em>, <em>’</em>, <em>’</em>, <em>’$’</em>, <em>’n’</em>, <em>‘5’</em>, <em>’V’</em>, <em>’o’</em>, <em>’x’</em>, <em>’#’</em>, <em>’s’</em>, <em>’}’</em>, <em>’Q’</em>, <em>’)’</em>, <em>‘1’</em>, <em>’M’</em>, <em>’X’</em>, <em>’b’</em>, <em>’I’</em>, <em>’.’</em>, <em>’F’</em>, <em>’h’</em>, <em>’W’</em>, <em>’-‘</em>, <em>’H’</em>, <em>’T’</em>, <em>’l’</em>, <em>’?’</em>, <em>’_’</em>, <em>”’”</em>, <em>‘9’</em>, <em>’j’</em>, <em>‘7’</em>, <em>’O’</em>, <em>’&lt;’</em>, <em>’(‘</em>, <em>’p’</em>, <em>’{‘</em>, <em>’x0b’</em>, <em>’e’</em>, <em>’R’</em>, <em>’`’</em>, <em>’C’</em>, <em>’D’</em>, <em>’k’</em>, <em>’]’</em>, <em>’f’</em>, <em>’t’</em>, <em>’E’</em>, <em>’q’</em>, <em>’”’</em>, <em>‘2’</em>, <em>’i’</em>, <em>’=’</em>, <em>’~’</em>, <em>’B’</em>, <em>’|’</em>, <em>‘4’</em>, <em>‘0’</em>, <em>‘3’</em>, <em>’m’</em>, <em>’d’</em>, <em>’L’</em>, <em>’c’</em>, <em>’%’</em>, <em>’P’</em>, <em>’&#64;’</em>, <em>’a’</em>, <em>’U’</em>, <em>’[‘</em>, <em>’g’</em>, <em>’S’</em>, <em>’r’</em>, <em>’A’</em>, <em>’ ‘</em>, <em>’v’</em>, <em>’N’</em>, <em>’n’</em>, <em>’+’</em>, <em>’^’</em>, <em>’'</em>, <em>’r’</em>, <em>’Z’</em>, <em>’*’</em>, <em>’/’</em>, <em>’w’</em>, <em>’G’</em>, <em>’t’</em>, <em>’!’</em>, <em>’J’</em>, <em>’z’</em>, <em>’&gt;’</em>, <em>’y’</em>, <em>‘6’</em>, <em>’Y’</em>, <em>’;’</em>, <em>’u’</em>, <em>’K’</em>, <em>’:’</em>, <em>’x0c’}</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/alphabet_domain.html#AlphabetLattice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.alphabet_domain.AlphabetLattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lyra.abstract_domains.string.html#lyra.abstract_domains.string.character_domain.CharacterLattice" title="lyra.abstract_domains.string.character_domain.CharacterLattice"><code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.string.character_domain.CharacterLattice</span></code></a>, <a class="reference internal" href="#lyra.abstract_domains.assumption.assumption_domain.JSONMixin" title="lyra.abstract_domains.assumption.assumption_domain.JSONMixin"><code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.assumption.assumption_domain.JSONMixin</span></code></a></p>
<p>Alphabet lattice.</p>
<p>The default abstraction is the unconstraining pair <code class="docutils literal"><span class="pre">(∅,</span> <span class="pre">Σ)</span></code>,
where <code class="docutils literal"><span class="pre">Σ</span></code> denotes the entire alphabet.
The bottom element of the lattice represents a contradiction.</p>
<dl class="method">
<dt id="lyra.abstract_domains.assumption.alphabet_domain.AlphabetLattice._less_equal">
<code class="descname">_less_equal</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.string.character_domain.CharacterLattice</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#lyra.abstract_domains.assumption.alphabet_domain.AlphabetLattice._less_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Partial order between default lattice elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> – other lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">whether the current lattice element is less than or equal to the other element</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal"><span class="pre">(c1,</span> <span class="pre">m1)</span> <span class="pre">⊑</span> <span class="pre">(c2,</span> <span class="pre">m2)</span></code> if and only if <code class="docutils literal"><span class="pre">c2</span> <span class="pre">⊆</span> <span class="pre">c1</span></code> and <code class="docutils literal"><span class="pre">m1</span> <span class="pre">⊆</span> <span class="pre">m2</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.alphabet_domain.AlphabetLattice._meet">
<code class="descname">_meet</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.string.character_domain.CharacterLattice</em><span class="sig-paren">)</span><a class="headerlink" href="#lyra.abstract_domains.assumption.alphabet_domain.AlphabetLattice._meet" title="Permalink to this definition">¶</a></dt>
<dd><p>Greatest lower bound between default lattice elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> – other lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to be the greatest lower bound</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal"><span class="pre">(c1,</span> <span class="pre">m1)</span> <span class="pre">⊓</span> <span class="pre">(c2,</span> <span class="pre">m2)</span> <span class="pre">=</span> <span class="pre">(c1</span> <span class="pre">∪</span> <span class="pre">c2,</span> <span class="pre">m1</span> <span class="pre">∩</span> <span class="pre">m2)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.alphabet_domain.AlphabetLattice._join">
<code class="descname">_join</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.string.character_domain.CharacterLattice</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.string.character_domain.CharacterLattice<a class="headerlink" href="#lyra.abstract_domains.assumption.alphabet_domain.AlphabetLattice._join" title="Permalink to this definition">¶</a></dt>
<dd><p>Least upper bound between default lattice elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> – other lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to be the least upper bound</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal"><span class="pre">(c1,</span> <span class="pre">m1)</span> <span class="pre">⊔</span> <span class="pre">(c2,</span> <span class="pre">m2)</span> <span class="pre">=</span> <span class="pre">(c1</span> <span class="pre">∩</span> <span class="pre">c2,</span> <span class="pre">m1</span> <span class="pre">∪</span> <span class="pre">m2)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.alphabet_domain.AlphabetLattice._widening">
<code class="descname">_widening</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.string.character_domain.CharacterLattice</em><span class="sig-paren">)</span><a class="headerlink" href="#lyra.abstract_domains.assumption.alphabet_domain.AlphabetLattice._widening" title="Permalink to this definition">¶</a></dt>
<dd><p>Widening between default lattice elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> – other lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to be the widening</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal"><span class="pre">(c1,</span> <span class="pre">m1)</span> <span class="pre">▽</span> <span class="pre">(c2,</span> <span class="pre">m2)</span> <span class="pre">=</span> <span class="pre">(c1,</span> <span class="pre">m1)</span> <span class="pre">⊔</span> <span class="pre">(c2,</span> <span class="pre">m2)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.alphabet_domain.AlphabetLattice._concat">
<code class="descname">_concat</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.string.character_domain.CharacterLattice</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.string.character_domain.CharacterLattice<a class="headerlink" href="#lyra.abstract_domains.assumption.alphabet_domain.AlphabetLattice._concat" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenation between two lattice elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> – other lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to be the concatenation</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal"><span class="pre">(c1,</span> <span class="pre">m1)</span> <span class="pre">+</span> <span class="pre">(c2,</span> <span class="pre">m2)</span> <span class="pre">=</span> <span class="pre">(c1</span> <span class="pre">∪</span> <span class="pre">c2,</span> <span class="pre">m1</span> <span class="pre">∪</span> <span class="pre">m2)</span></code>.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="lyra.abstract_domains.assumption.alphabet_domain.AlphabetLattice.from_json">
<em class="property">static </em><code class="descname">from_json</code><span class="sig-paren">(</span><em>json: dict</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.JSONMixin<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/alphabet_domain.html#AlphabetLattice.from_json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.alphabet_domain.AlphabetLattice.from_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstruct a lattice element from its JSON format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>json</strong> – JSON format of a lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">reconstructed lattice element from its JSON format</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.alphabet_domain.AlphabetLattice.to_json">
<code class="descname">to_json</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; dict<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/alphabet_domain.html#AlphabetLattice.to_json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.alphabet_domain.AlphabetLattice.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the current lattice element to JSON format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">JSON format of the current lattice element</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lyra.abstract_domains.assumption.alphabet_domain.AlphabetState">
<em class="property">class </em><code class="descclassname">lyra.abstract_domains.assumption.alphabet_domain.</code><code class="descname">AlphabetState</code><span class="sig-paren">(</span><em>variables: typing.Set[lyra.core.expressions.VariableIdentifier], precursory: lyra.abstract_domains.assumption.assumption_domain.InputMixin = None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/alphabet_domain.html#AlphabetState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.alphabet_domain.AlphabetState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lyra.abstract_domains.string.html#lyra.abstract_domains.string.character_domain.CharacterState" title="lyra.abstract_domains.string.character_domain.CharacterState"><code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.string.character_domain.CharacterState</span></code></a>, <a class="reference internal" href="#lyra.abstract_domains.assumption.assumption_domain.InputMixin" title="lyra.abstract_domains.assumption.assumption_domain.InputMixin"><code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.assumption.assumption_domain.InputMixin</span></code></a></p>
<p>Alphabet analysis state. An element of the alphabet abstract domain.</p>
<p>Map from each program variable to the sets of characters
that must and may form its possible string values.
The string value of all program variables is unconstrained by default.</p>
<p>When reading input data, the corresponding range assumptions
are stored in the class member <code class="docutils literal"><span class="pre">inputs</span></code>, which is a map from each program point
to the list of range assumptions on the input data read at that point.</p>
<dl class="method">
<dt id="lyra.abstract_domains.assumption.alphabet_domain.AlphabetState._assume">
<code class="descname">_assume</code><span class="sig-paren">(</span><em>condition: lyra.core.expressions.Expression</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.state.State<a class="headerlink" href="#lyra.abstract_domains.assumption.alphabet_domain.AlphabetState._assume" title="Permalink to this definition">¶</a></dt>
<dd><p>Assume that some condition holds in the current state.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>condition</strong> – expression representing the assumed condition</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current state modified to satisfy the assumption</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.alphabet_domain.AlphabetState._substitute">
<code class="descname">_substitute</code><span class="sig-paren">(</span><em>left: lyra.core.expressions.Expression</em>, <em>right: lyra.core.expressions.Expression</em><span class="sig-paren">)</span><a class="headerlink" href="#lyra.abstract_domains.assumption.alphabet_domain.AlphabetState._substitute" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitute an expression to another expression.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>left</strong> – expression to be substituted</li>
<li><strong>right</strong> – expression to substitute</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">current state modified by the substitution</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="lyra.abstract_domains.assumption.alphabet_domain.AlphabetState.ExpressionRefinement">
<em class="property">class </em><code class="descname">ExpressionRefinement</code><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/alphabet_domain.html#AlphabetState.ExpressionRefinement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.alphabet_domain.AlphabetState.ExpressionRefinement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.string.character_domain.ExpressionRefinement</span></code></p>
<dl class="method">
<dt id="lyra.abstract_domains.assumption.alphabet_domain.AlphabetState.ExpressionRefinement.visit_Input">
<code class="descname">visit_Input</code><span class="sig-paren">(</span><em>expr</em>, <em>evaluation=None</em>, <em>value=None</em>, <em>state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/alphabet_domain.html#AlphabetState.ExpressionRefinement.visit_Input"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.alphabet_domain.AlphabetState.ExpressionRefinement.visit_Input" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of an input call expression.</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.alphabet_domain.AlphabetState.replace">
<code class="descname">replace</code><span class="sig-paren">(</span><em>variable: lyra.core.expressions.VariableIdentifier</em>, <em>expression: lyra.core.expressions.Expression</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.alphabet_domain.AlphabetState<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/alphabet_domain.html#AlphabetState.replace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.alphabet_domain.AlphabetState.replace" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.alphabet_domain.AlphabetState.unify">
<code class="descname">unify</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.assumption.alphabet_domain.AlphabetState</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.alphabet_domain.AlphabetState<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/alphabet_domain.html#AlphabetState.unify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.alphabet_domain.AlphabetState.unify" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<span class="target" id="module-lyra.abstract_domains.assumption.assumption_domain"></span><div class="section" id="assumption-abstract-domains">
<h3>Assumption Abstract Domains<a class="headerlink" href="#assumption-abstract-domains" title="Permalink to this headline">¶</a></h3>
<p>Abstract domains to be used for <strong>input data assumption analysis</strong>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body">Caterina Urban and Radwa Sherif Abdelbar</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState">
<em class="property">class </em><code class="descclassname">lyra.abstract_domains.assumption.assumption_domain.</code><code class="descname">AssumptionState</code><span class="sig-paren">(</span><em>states: typing.List[typing.Type[lyra.abstract_domains.assumption.assumption_domain.InputMixin]], arguments: typing.Dict[typing.Type, typing.Dict[str, typing.Any]] = defaultdict(&lt;function AssumptionState.&lt;lambda&gt;&gt;, {}), precursory: lyra.abstract_domains.state.State = None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lyra.abstract_domains.html#lyra.abstract_domains.state.State" title="lyra.abstract_domains.state.State"><code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.state.State</span></code></a></p>
<p>Assumption analysis state. An element of the assumption abstract domain.</p>
<p>Reduced product of a list of constraining states,
which collect constraints on the program variables and (indirectly) on the input data,
and a stack of assumptions on the input data,
which (directly) constraints the input data read from the current program point.</p>
<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState._assume">
<code class="descname">_assume</code><span class="sig-paren">(</span><em>condition: lyra.core.expressions.Expression</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.AssumptionState<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState._assume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState._assume" title="Permalink to this definition">¶</a></dt>
<dd><p>Assume that some condition holds in the current state.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>condition</strong> – expression representing the assumed condition</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current state modified to satisfy the assumption</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState._substitute">
<code class="descname">_substitute</code><span class="sig-paren">(</span><em>left: lyra.core.expressions.Expression</em>, <em>right: lyra.core.expressions.Expression</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.AssumptionState<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState._substitute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState._substitute" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitute an expression to another expression.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>left</strong> – expression to be substituted</li>
<li><strong>right</strong> – expression to substitute</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">current state modified by the substitution</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack">
<em class="property">class </em><code class="descname">InputStack</code><span class="sig-paren">(</span><em>precursory: lyra.abstract_domains.state.State = None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lyra.abstract_domains.html#lyra.abstract_domains.stack.Stack" title="lyra.abstract_domains.stack.Stack"><code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.stack.Stack</span></code></a>, <a class="reference internal" href="lyra.abstract_domains.html#lyra.abstract_domains.state.State" title="lyra.abstract_domains.state.State"><code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.state.State</span></code></a></p>
<p>Stack of assumptions on the input data.</p>
<dl class="class">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputLattice">
<em class="property">class </em><code class="descname">InputLattice</code><span class="sig-paren">(</span><em>multiplier: lyra.core.expressions.Expression = &lt;lyra.core.expressions.Literal object&gt;, constraints: typing.List[typing.Union[typing.Tuple[lyra.core.statements.ProgramPoint, …], typing.Tuple[lyra.core.statements.ProgramPoint, typing.Tuple[lyra.abstract_domains.assumption.assumption_domain.JSONMixin, …]], _ForwardRef(‘AssumptionState.InputStack.InputLattice’)]] = []</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.InputLattice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputLattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lyra.abstract_domains.html#lyra.abstract_domains.lattice.BottomMixin" title="lyra.abstract_domains.lattice.BottomMixin"><code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.lattice.BottomMixin</span></code></a></p>
<p>Assumptions on the input data.</p>
<p>Each assumption is a (possibly symbolic) repetition of constraints on the input data.
A constraint can be:</p>
<ul class="simple">
<li>a basic constraint, i.e., a tuple of lattices (l, …)
which indicates that an input data point is expected and restricts its possible value</li>
<li>a star constraint, i.e., ★
which indicates that any number of input data points is expected</li>
<li>another symbolically repeated assumption</li>
</ul>
<p>Let S be the set of all possible sequences of input data points.
The concretization function Ɣ: InputLattice -&gt; 𝒫(S) is defined as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>Ɣ(1 * [★]) = S
...
Ɣ(1 * [(l1, l2), ★]) = { xs ∈ S | x ∈ Ɣ(l1) ⋂ Ɣ(l2) }
...
Ɣ(n * [(l1, l2)]) = { x^n ∈ S | x ∈ Ɣ(l1) ⋂ Ɣ(l2) }
...
Ɣ(1 * [(l1, l2)]) = { x ∈ S | x ∈ Ɣ(l1) ⋂ Ɣ(l2) }
...
Ɣ(1 * []) = { ε }
</pre></div>
</div>
<dl class="attribute">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputLattice.BasicConstraint">
<code class="descname">BasicConstraint</code><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputLattice.BasicConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal"><span class="pre">Tuple</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputLattice.InputConstraint">
<code class="descname">InputConstraint</code><em class="property"> = typing.Union[typing.Tuple[lyra.core.statements.ProgramPoint, …], typing.Tuple[lyra.core.statements.ProgramPoint, typing.Tuple[lyra.abstract_domains.assumption.assumption_domain.JSONMixin, …]], _ForwardRef(‘AssumptionState.InputStack.InputLattice’)]</em><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputLattice.InputConstraint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputLattice.InputLattice">
<code class="descname">InputLattice</code><em class="property"> = ‘AssumptionState.InputStack.InputLattice’</em><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputLattice.InputLattice" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputLattice.StarConstraint">
<code class="descname">StarConstraint</code><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputLattice.StarConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal"><span class="pre">Tuple</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputLattice.constraints">
<code class="descname">constraints</code><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputLattice.constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Current list of constraints.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputLattice.is_top">
<code class="descname">is_top</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.InputLattice.is_top"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputLattice.is_top" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the lattice element is top.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">whether the lattice element is top</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputLattice.multiplier">
<code class="descname">multiplier</code><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputLattice.multiplier" title="Permalink to this definition">¶</a></dt>
<dd><p>Current multiplier.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputLattice.record">
<code class="descname">record</code><span class="sig-paren">(</span><em>constraint: typing.Union[typing.Tuple[lyra.core.statements.ProgramPoint, …], typing.Tuple[lyra.core.statements.ProgramPoint, typing.Tuple[lyra.abstract_domains.assumption.assumption_domain.JSONMixin, …]], _ForwardRef(‘AssumptionState.InputStack.InputLattice’)]</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputLattice<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.InputLattice.record"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputLattice.record" title="Permalink to this definition">¶</a></dt>
<dd><p>Record a constraint on the input data.</p>
<p>By default, the constraint is added to the current list of recorded constraints.</p>
<p>When leaving the body of a for loop another time than the first, the constraint
to be recorded is instead merged with the previously recorded constraint.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>constraint</strong> – constraint to be recorded</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to record the constraint</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputLattice.repeat">
<code class="descname">repeat</code><span class="sig-paren">(</span><em>multiplier: lyra.core.expressions.Expression</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputLattice<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.InputLattice.repeat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputLattice.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Repeat the current assumption on the input data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>multiplier</strong> – repetitions to be performed</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to repeat the assumption</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputLattice.replace">
<code class="descname">replace</code><span class="sig-paren">(</span><em>variable: lyra.core.expressions.VariableIdentifier</em>, <em>expression: lyra.core.expressions.Expression</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.InputLattice.replace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputLattice.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace a variable with an expression.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> – variable to be replaced</li>
<li><strong>expression</strong> – expression replacing the variable</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">current lattice element modified to manifest the replacement</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputLattice.top">
<code class="descname">top</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.InputLattice.top"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputLattice.top" title="Permalink to this definition">¶</a></dt>
<dd><p>Top lattice element.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to be the top lattice element</td>
</tr>
</tbody>
</table>
<p>The top lattice element is <code class="docutils literal"><span class="pre">1</span> <span class="pre">*</span> <span class="pre">[★]</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement">
<em class="property">class </em><code class="descname">InputReplacement</code><span class="sig-paren">(</span><em>pp: lyra.core.statements.ProgramPoint</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.InputReplacement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lyra.core.html#lyra.core.expressions.ExpressionVisitor" title="lyra.core.expressions.ExpressionVisitor"><code class="xref py py-class docutils literal"><span class="pre">lyra.core.expressions.ExpressionVisitor</span></code></a></p>
<p>Visitor that replaces any occurrence of an input (sub)expression
with a fresh variable identifier that depends on a given program point.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">input</span><span class="p">()</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="nb">input</span><span class="p">()</span>
</pre></div>
</div>
<p>given the program point [line:L, column:C] becomes:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">L</span><span class="o">.</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">L</span><span class="o">.</span><span class="mi">2</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.nonce">
<code class="descname">nonce</code><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.nonce" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.pp">
<code class="descname">pp</code><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.pp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_AttributeReference">
<code class="descname">visit_AttributeReference</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.AttributeReference</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.InputReplacement.visit_AttributeReference"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_AttributeReference" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of an attribute reference.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_BinaryArithmeticOperation">
<code class="descname">visit_BinaryArithmeticOperation</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.BinaryArithmeticOperation</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.InputReplacement.visit_BinaryArithmeticOperation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_BinaryArithmeticOperation" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a binary arithmetic operation.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_BinaryBooleanOperation">
<code class="descname">visit_BinaryBooleanOperation</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.BinaryBooleanOperation</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.InputReplacement.visit_BinaryBooleanOperation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_BinaryBooleanOperation" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a binary boolean operation.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_BinaryComparisonOperation">
<code class="descname">visit_BinaryComparisonOperation</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.BinaryComparisonOperation</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.InputReplacement.visit_BinaryComparisonOperation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_BinaryComparisonOperation" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a binary comparison operation.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_BinarySequenceOperation">
<code class="descname">visit_BinarySequenceOperation</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.BinarySequenceOperation</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.InputReplacement.visit_BinarySequenceOperation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_BinarySequenceOperation" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a binary sequence operation.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_DictDisplay">
<code class="descname">visit_DictDisplay</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.DictDisplay</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.InputReplacement.visit_DictDisplay"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_DictDisplay" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of dictionary display.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_Input">
<code class="descname">visit_Input</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.Input</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.InputReplacement.visit_Input"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_Input" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of an input call expression.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_LengthIdentifier">
<code class="descname">visit_LengthIdentifier</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.LengthIdentifier</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.InputReplacement.visit_LengthIdentifier"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_LengthIdentifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a sequence or collection length.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_ListDisplay">
<code class="descname">visit_ListDisplay</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.ListDisplay</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.InputReplacement.visit_ListDisplay"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_ListDisplay" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a list display.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_Literal">
<code class="descname">visit_Literal</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.Literal</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.InputReplacement.visit_Literal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_Literal" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a literal expression.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_Range">
<code class="descname">visit_Range</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.Range</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.InputReplacement.visit_Range"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_Range" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a range call expression.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_SetDisplay">
<code class="descname">visit_SetDisplay</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.SetDisplay</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.InputReplacement.visit_SetDisplay"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_SetDisplay" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a set display.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_Slicing">
<code class="descname">visit_Slicing</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.Slicing</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.InputReplacement.visit_Slicing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_Slicing" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a slicing expression.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_Subscription">
<code class="descname">visit_Subscription</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.Subscription</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.InputReplacement.visit_Subscription"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_Subscription" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a subscription expression.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_TupleDisplay">
<code class="descname">visit_TupleDisplay</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.TupleDisplay</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.InputReplacement.visit_TupleDisplay"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_TupleDisplay" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a tuple display.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_UnaryArithmeticOperation">
<code class="descname">visit_UnaryArithmeticOperation</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.UnaryArithmeticOperation</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.InputReplacement.visit_UnaryArithmeticOperation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_UnaryArithmeticOperation" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a unary arithmetic operation.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_UnaryBooleanOperation">
<code class="descname">visit_UnaryBooleanOperation</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.UnaryBooleanOperation</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.InputReplacement.visit_UnaryBooleanOperation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_UnaryBooleanOperation" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a unary boolean operation.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_VariableIdentifier">
<code class="descname">visit_VariableIdentifier</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.VariableIdentifier</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.InputReplacement.visit_VariableIdentifier"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.InputReplacement.visit_VariableIdentifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a variable identifier.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.Scope">
<em class="property">class </em><code class="descname">Scope</code><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.Scope"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.Scope" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">enum.Enum</span></code></p>
<p>Scope type. Either <code class="docutils literal"><span class="pre">Branch</span></code> or <code class="docutils literal"><span class="pre">Loop</span></code>.</p>
<dl class="attribute">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.Scope.Branch">
<code class="descname">Branch</code><em class="property"> = 0</em><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.Scope.Branch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.Scope.Loop">
<code class="descname">Loop</code><em class="property"> = 1</em><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.Scope.Loop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.enter_if">
<code class="descname">enter_if</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.enter_if"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.enter_if" title="Permalink to this definition">¶</a></dt>
<dd><p>Enter a conditional if statement.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">current state modified to enter a conditional if statement</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.enter_loop">
<code class="descname">enter_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.enter_loop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.enter_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Enter a loop.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">current state modified to enter a loop</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.exit_if">
<code class="descname">exit_if</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.exit_if"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.exit_if" title="Permalink to this definition">¶</a></dt>
<dd><p>Exit a conditional if statement.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">current state modified to enter a conditional if statement</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.exit_loop">
<code class="descname">exit_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.exit_loop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.exit_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Exit a loop.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">current state modified to exit a loop</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.pop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Pop an element from the current stack.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.push">
<code class="descname">push</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.push"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.push" title="Permalink to this definition">¶</a></dt>
<dd><p>Push an element on the current stack.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.record">
<code class="descname">record</code><span class="sig-paren">(</span><em>constraint: typing.Union[typing.Tuple[lyra.core.statements.ProgramPoint, …], typing.Tuple[lyra.core.statements.ProgramPoint, typing.Tuple[lyra.abstract_domains.assumption.assumption_domain.JSONMixin, …]], _ForwardRef(‘AssumptionState.InputStack.InputLattice’)]</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.InputStack.record"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.record" title="Permalink to this definition">¶</a></dt>
<dd><p>Record a constraint on the input data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>constraint</strong> – constraint to be recorded</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current stack modified to record the constraint</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.scope">
<code class="descname">scope</code><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.scope" title="Permalink to this definition">¶</a></dt>
<dd><p>Current scope type.</p>
</dd></dl>

<dl class="attribute">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.scopes">
<code class="descname">scopes</code><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.InputStack.scopes" title="Permalink to this definition">¶</a></dt>
<dd><p>Current stack of scope types.</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.before">
<code class="descname">before</code><span class="sig-paren">(</span><em>pp: lyra.core.statements.ProgramPoint, precursory: typing.Union[_ForwardRef(‘State’), NoneType]</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.AssumptionState<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.before"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.before" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the program point of the currently analyzed statement
and the current precursory analysis state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pp</strong> – current program point</li>
<li><strong>precursory</strong> – current precursory analysis state</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">current state modified to set the current program point and precursory state</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.bottom">
<code class="descname">bottom</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.AssumptionState<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.bottom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.bottom" title="Permalink to this definition">¶</a></dt>
<dd><p>Bottom lattice element.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to be the bottom lattice element</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.enter_if">
<code class="descname">enter_if</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.AssumptionState<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.enter_if"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.enter_if" title="Permalink to this definition">¶</a></dt>
<dd><p>Enter a conditional if statement.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">current state modified to enter a conditional if statement</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.enter_loop">
<code class="descname">enter_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.AssumptionState<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.enter_loop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.enter_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Enter a loop.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">current state modified to enter a loop</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.exit_if">
<code class="descname">exit_if</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.AssumptionState<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.exit_if"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.exit_if" title="Permalink to this definition">¶</a></dt>
<dd><p>Exit a conditional if statement.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">current state modified to enter a conditional if statement</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.exit_loop">
<code class="descname">exit_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.AssumptionState<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.exit_loop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.exit_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Exit a loop.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">current state modified to exit a loop</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.is_bottom">
<code class="descname">is_bottom</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.is_bottom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.is_bottom" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the lattice element is bottom.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">whether the lattice element is bottom</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.is_top">
<code class="descname">is_top</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.is_top"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.is_top" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the lattice element is top.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">whether the lattice element is top</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.stack">
<code class="descname">stack</code><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.stack" title="Permalink to this definition">¶</a></dt>
<dd><p>Current stack of assumptions on the input data.</p>
</dd></dl>

<dl class="attribute">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.states">
<code class="descname">states</code><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.states" title="Permalink to this definition">¶</a></dt>
<dd><p>Current list of constraining states.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.AssumptionState.top">
<code class="descname">top</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.AssumptionState<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#AssumptionState.top"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState.top" title="Permalink to this definition">¶</a></dt>
<dd><p>Top lattice element.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to be the top lattice element</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lyra.abstract_domains.assumption.assumption_domain.InputMixin">
<em class="property">class </em><code class="descclassname">lyra.abstract_domains.assumption.assumption_domain.</code><code class="descname">InputMixin</code><span class="sig-paren">(</span><em>precursory: lyra.abstract_domains.state.State = None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#InputMixin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.InputMixin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lyra.abstract_domains.html#lyra.abstract_domains.state.State" title="lyra.abstract_domains.state.State"><code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.state.State</span></code></a></p>
<p>Mixin to add a mechanism for recording and retrieving constraints on the input data.</p>
<p>Constraints are recorded in the class member <code class="docutils literal"><span class="pre">inputs</span></code>, which is a map
from each program point to the list of constraints on the input data read at that point.</p>
<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.InputMixin.join">
<code class="descname">join</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.assumption.assumption_domain.InputMixin</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#InputMixin.join"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.InputMixin.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Least upper bound between lattice elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> – other lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to be the least upper bound</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.InputMixin.less_equal">
<code class="descname">less_equal</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.assumption.assumption_domain.InputMixin</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#InputMixin.less_equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.InputMixin.less_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Partial order between lattice elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> – other lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">whether the current lattice element is less than or equal to the other element</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.InputMixin.meet">
<code class="descname">meet</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.assumption.assumption_domain.InputMixin</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#InputMixin.meet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.InputMixin.meet" title="Permalink to this definition">¶</a></dt>
<dd><p>Least upper bound between lattice elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> – other lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to be the least upper bound</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.InputMixin.record">
<code class="descname">record</code><span class="sig-paren">(</span><em>constraint: lyra.abstract_domains.assumption.assumption_domain.JSONMixin</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.InputMixin<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#InputMixin.record"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.InputMixin.record" title="Permalink to this definition">¶</a></dt>
<dd><p>Record an constraint.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>constraint</strong> – constraint to be recorded</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current state modified to record the constraint</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.InputMixin.replace">
<code class="descname">replace</code><span class="sig-paren">(</span><em>variable: lyra.core.expressions.VariableIdentifier</em>, <em>expression: lyra.core.expressions.Expression</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.InputMixin<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#InputMixin.replace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.InputMixin.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace a variable with an expression.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The new variables appearing in the replacing expression are added to the current state.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> – variable to be replaced</li>
<li><strong>expression</strong> – expression replacing the variable</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">current state modified to manifest the replacement</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.InputMixin.retrieve">
<code class="descname">retrieve</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; typing.List[lyra.abstract_domains.assumption.assumption_domain.JSONMixin]<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#InputMixin.retrieve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.InputMixin.retrieve" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve and forget the constraints corresponding to the current program point.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state is modified to forget the returned constraints.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the list of constraints corresponding to the current program point</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.InputMixin.unify">
<code class="descname">unify</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.assumption.assumption_domain.InputMixin</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.InputMixin<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#InputMixin.unify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.InputMixin.unify" title="Permalink to this definition">¶</a></dt>
<dd><p>Unification of the environment of the current state
with the environment of another state.</p>
<p>This is needed when new variables are introduced by <code class="docutils literal"><span class="pre">replace()</span></code>
to represent input expressions. The unification should match variables
in the order of the program points on which they depend.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> – state whose environment we want to unify with</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current state modified to reflect the unification</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.InputMixin.widening">
<code class="descname">widening</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.assumption.assumption_domain.InputMixin</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#InputMixin.widening"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.InputMixin.widening" title="Permalink to this definition">¶</a></dt>
<dd><p>Least upper bound between lattice elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> – other lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to be the least upper bound</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lyra.abstract_domains.assumption.assumption_domain.JSONMixin">
<em class="property">class </em><code class="descclassname">lyra.abstract_domains.assumption.assumption_domain.</code><code class="descname">JSONMixin</code><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#JSONMixin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.JSONMixin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lyra.abstract_domains.html#lyra.abstract_domains.lattice.Lattice" title="lyra.abstract_domains.lattice.Lattice"><code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.lattice.Lattice</span></code></a></p>
<p>Mixin to add a mechanism for converting a lattice to and from JSON format.</p>
<dl class="staticmethod">
<dt id="lyra.abstract_domains.assumption.assumption_domain.JSONMixin.from_json">
<em class="property">static </em><code class="descname">from_json</code><span class="sig-paren">(</span><em>json: str</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.JSONMixin<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#JSONMixin.from_json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.JSONMixin.from_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstruct a lattice element from its JSON format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>json</strong> – JSON format of a lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">reconstructed lattice element from its JSON format</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.JSONMixin.to_json">
<code class="descname">to_json</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#JSONMixin.to_json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.JSONMixin.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the current lattice element to JSON format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">JSON format of the current lattice element</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lyra.abstract_domains.assumption.assumption_domain.TypeAlphabetAssumptionState">
<em class="property">class </em><code class="descclassname">lyra.abstract_domains.assumption.assumption_domain.</code><code class="descname">TypeAlphabetAssumptionState</code><span class="sig-paren">(</span><em>variables: typing.Set[lyra.core.expressions.VariableIdentifier], precursory: lyra.abstract_domains.state.State = None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#TypeAlphabetAssumptionState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.TypeAlphabetAssumptionState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState" title="lyra.abstract_domains.assumption.assumption_domain.AssumptionState"><code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.assumption.assumption_domain.AssumptionState</span></code></a></p>
<p>Type+alphabet assumption analysis state.</p>
<p>Reduced product of type and string constraining states,
and a stack of assumptions on the input data.</p>
<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.TypeAlphabetAssumptionState._assume">
<code class="descname">_assume</code><span class="sig-paren">(</span><em>condition: lyra.core.expressions.Expression</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.AssumptionState<a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.TypeAlphabetAssumptionState._assume" title="Permalink to this definition">¶</a></dt>
<dd><p>Assume that some condition holds in the current state.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>condition</strong> – expression representing the assumed condition</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current state modified to satisfy the assumption</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.TypeAlphabetAssumptionState._substitute">
<code class="descname">_substitute</code><span class="sig-paren">(</span><em>left: lyra.core.expressions.Expression</em>, <em>right: lyra.core.expressions.Expression</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.AssumptionState<a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.TypeAlphabetAssumptionState._substitute" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitute an expression to another expression.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>left</strong> – expression to be substituted</li>
<li><strong>right</strong> – expression to substitute</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">current state modified by the substitution</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lyra.abstract_domains.assumption.assumption_domain.TypeQuantityAssumptionState">
<em class="property">class </em><code class="descclassname">lyra.abstract_domains.assumption.assumption_domain.</code><code class="descname">TypeQuantityAssumptionState</code><span class="sig-paren">(</span><em>variables: typing.Set[lyra.core.expressions.VariableIdentifier], precursory: lyra.abstract_domains.state.State = None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#TypeQuantityAssumptionState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.TypeQuantityAssumptionState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState" title="lyra.abstract_domains.assumption.assumption_domain.AssumptionState"><code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.assumption.assumption_domain.AssumptionState</span></code></a></p>
<p>Type+quantity assumption analysis state.
An element of the type+quantity assumption abstract domain.</p>
<p>Reduced product of type and quantity constraining states,
which respectively collect constraints on the type and sign of values of the program variables
and (indirectly) on the input data, and a stack of assumptions on the input data,
which (directly) constraints the input data read from the current program point.</p>
<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.TypeQuantityAssumptionState._assume">
<code class="descname">_assume</code><span class="sig-paren">(</span><em>condition: lyra.core.expressions.Expression</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.AssumptionState<a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.TypeQuantityAssumptionState._assume" title="Permalink to this definition">¶</a></dt>
<dd><p>Assume that some condition holds in the current state.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>condition</strong> – expression representing the assumed condition</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current state modified to satisfy the assumption</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.TypeQuantityAssumptionState._substitute">
<code class="descname">_substitute</code><span class="sig-paren">(</span><em>left: lyra.core.expressions.Expression</em>, <em>right: lyra.core.expressions.Expression</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.AssumptionState<a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.TypeQuantityAssumptionState._substitute" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitute an expression to another expression.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>left</strong> – expression to be substituted</li>
<li><strong>right</strong> – expression to substitute</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">current state modified by the substitution</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lyra.abstract_domains.assumption.assumption_domain.TypeRangeAlphabetAssumptionState">
<em class="property">class </em><code class="descclassname">lyra.abstract_domains.assumption.assumption_domain.</code><code class="descname">TypeRangeAlphabetAssumptionState</code><span class="sig-paren">(</span><em>variables: typing.Set[lyra.core.expressions.VariableIdentifier], precursory: lyra.abstract_domains.state.State = None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#TypeRangeAlphabetAssumptionState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.TypeRangeAlphabetAssumptionState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState" title="lyra.abstract_domains.assumption.assumption_domain.AssumptionState"><code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.assumption.assumption_domain.AssumptionState</span></code></a></p>
<p>Type+range+alphabet assumption analysis state.</p>
<p>Reduced product of type, range, and string constraining states,
and a stack of assumptions on the input data.</p>
<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.TypeRangeAlphabetAssumptionState._assume">
<code class="descname">_assume</code><span class="sig-paren">(</span><em>condition: lyra.core.expressions.Expression</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.AssumptionState<a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.TypeRangeAlphabetAssumptionState._assume" title="Permalink to this definition">¶</a></dt>
<dd><p>Assume that some condition holds in the current state.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>condition</strong> – expression representing the assumed condition</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current state modified to satisfy the assumption</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.TypeRangeAlphabetAssumptionState._substitute">
<code class="descname">_substitute</code><span class="sig-paren">(</span><em>left: lyra.core.expressions.Expression</em>, <em>right: lyra.core.expressions.Expression</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.AssumptionState<a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.TypeRangeAlphabetAssumptionState._substitute" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitute an expression to another expression.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>left</strong> – expression to be substituted</li>
<li><strong>right</strong> – expression to substitute</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">current state modified by the substitution</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lyra.abstract_domains.assumption.assumption_domain.TypeRangeAssumptionState">
<em class="property">class </em><code class="descclassname">lyra.abstract_domains.assumption.assumption_domain.</code><code class="descname">TypeRangeAssumptionState</code><span class="sig-paren">(</span><em>variables: typing.Set[lyra.core.expressions.VariableIdentifier], precursory: lyra.abstract_domains.state.State = None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/assumption_domain.html#TypeRangeAssumptionState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.TypeRangeAssumptionState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lyra.abstract_domains.assumption.assumption_domain.AssumptionState" title="lyra.abstract_domains.assumption.assumption_domain.AssumptionState"><code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.assumption.assumption_domain.AssumptionState</span></code></a></p>
<p>Type+range assumption analysis state.
An element of the type+range assumption abstract domain.</p>
<p>Reduced product of type and range constraining states,
which respectively collect constraints on the type and range of values of the program variables
and (indirectly) on the input data, and a stack of assumptions on the input data,
which (directly) constraints the input data read from the current program point.</p>
<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.TypeRangeAssumptionState._assume">
<code class="descname">_assume</code><span class="sig-paren">(</span><em>condition: lyra.core.expressions.Expression</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.AssumptionState<a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.TypeRangeAssumptionState._assume" title="Permalink to this definition">¶</a></dt>
<dd><p>Assume that some condition holds in the current state.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>condition</strong> – expression representing the assumed condition</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current state modified to satisfy the assumption</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.assumption_domain.TypeRangeAssumptionState._substitute">
<code class="descname">_substitute</code><span class="sig-paren">(</span><em>left: lyra.core.expressions.Expression</em>, <em>right: lyra.core.expressions.Expression</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.AssumptionState<a class="headerlink" href="#lyra.abstract_domains.assumption.assumption_domain.TypeRangeAssumptionState._substitute" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitute an expression to another expression.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>left</strong> – expression to be substituted</li>
<li><strong>right</strong> – expression to substitute</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">current state modified by the substitution</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<span class="target" id="module-lyra.abstract_domains.assumption.quantity_domain"></span><div class="section" id="quantity-abstract-domain">
<h3>Quantity Abstract Domain<a class="headerlink" href="#quantity-abstract-domain" title="Permalink to this headline">¶</a></h3>
<p>Non-relational abstract domain to be used for <strong>input data assumptions analysis</strong>.
The set of possible values of a program variables in a program state
is represented by their sign (negative, zero, positive, …)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body">Caterina Urban</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="lyra.abstract_domains.assumption.quantity_domain.QuantityLattice">
<em class="property">class </em><code class="descclassname">lyra.abstract_domains.assumption.quantity_domain.</code><code class="descname">QuantityLattice</code><span class="sig-paren">(</span><em>negative=True</em>, <em>zero=True</em>, <em>positive=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/quantity_domain.html#QuantityLattice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.quantity_domain.QuantityLattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lyra.abstract_domains.numerical.html#lyra.abstract_domains.numerical.sign_domain.SignLattice" title="lyra.abstract_domains.numerical.sign_domain.SignLattice"><code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.numerical.sign_domain.SignLattice</span></code></a>, <a class="reference internal" href="#lyra.abstract_domains.assumption.assumption_domain.JSONMixin" title="lyra.abstract_domains.assumption.assumption_domain.JSONMixin"><code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.assumption.assumption_domain.JSONMixin</span></code></a></p>
<p>Quantity lattice.</p>
<img alt="_images/sign.png" src="_images/sign.png" />
<dl class="method">
<dt id="lyra.abstract_domains.assumption.quantity_domain.QuantityLattice._less_equal">
<code class="descname">_less_equal</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.numerical.sign_domain.SignLattice</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#lyra.abstract_domains.assumption.quantity_domain.QuantityLattice._less_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Partial order between default lattice elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> – other lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">whether the current lattice element is less than or equal to the other element</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.quantity_domain.QuantityLattice._meet">
<code class="descname">_meet</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.numerical.sign_domain.SignLattice</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.numerical.sign_domain.SignLattice<a class="headerlink" href="#lyra.abstract_domains.assumption.quantity_domain.QuantityLattice._meet" title="Permalink to this definition">¶</a></dt>
<dd><p>Greatest lower bound between default lattice elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> – other lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to be the greatest lower bound</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.quantity_domain.QuantityLattice._join">
<code class="descname">_join</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.numerical.sign_domain.SignLattice</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.numerical.sign_domain.SignLattice<a class="headerlink" href="#lyra.abstract_domains.assumption.quantity_domain.QuantityLattice._join" title="Permalink to this definition">¶</a></dt>
<dd><p>Least upper bound between default lattice elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> – other lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to be the least upper bound</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.quantity_domain.QuantityLattice._widening">
<code class="descname">_widening</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.numerical.sign_domain.SignLattice</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.numerical.sign_domain.SignLattice<a class="headerlink" href="#lyra.abstract_domains.assumption.quantity_domain.QuantityLattice._widening" title="Permalink to this definition">¶</a></dt>
<dd><p>Widening between default lattice elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> – other lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to be the widening</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.quantity_domain.QuantityLattice._neg">
<code class="descname">_neg</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.numerical.sign_domain.SignLattice<a class="headerlink" href="#lyra.abstract_domains.assumption.quantity_domain.QuantityLattice._neg" title="Permalink to this definition">¶</a></dt>
<dd><p>Negation of a default lattice elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to be its negation</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.quantity_domain.QuantityLattice._add">
<code class="descname">_add</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.numerical.sign_domain.SignLattice</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.numerical.sign_domain.SignLattice<a class="headerlink" href="#lyra.abstract_domains.assumption.quantity_domain.QuantityLattice._add" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.quantity_domain.QuantityLattice._sub">
<code class="descname">_sub</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.numerical.sign_domain.SignLattice</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.numerical.sign_domain.SignLattice<a class="headerlink" href="#lyra.abstract_domains.assumption.quantity_domain.QuantityLattice._sub" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.quantity_domain.QuantityLattice._mult">
<code class="descname">_mult</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.numerical.sign_domain.SignLattice</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.numerical.sign_domain.SignLattice<a class="headerlink" href="#lyra.abstract_domains.assumption.quantity_domain.QuantityLattice._mult" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="lyra.abstract_domains.assumption.quantity_domain.QuantityLattice.from_json">
<em class="property">static </em><code class="descname">from_json</code><span class="sig-paren">(</span><em>json: str</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.JSONMixin<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/quantity_domain.html#QuantityLattice.from_json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.quantity_domain.QuantityLattice.from_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstruct a lattice element from its JSON format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>json</strong> – JSON format of a lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">reconstructed lattice element from its JSON format</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.quantity_domain.QuantityLattice.to_json">
<code class="descname">to_json</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/quantity_domain.html#QuantityLattice.to_json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.quantity_domain.QuantityLattice.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the current lattice element to JSON format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">JSON format of the current lattice element</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lyra.abstract_domains.assumption.quantity_domain.QuantityState">
<em class="property">class </em><code class="descclassname">lyra.abstract_domains.assumption.quantity_domain.</code><code class="descname">QuantityState</code><span class="sig-paren">(</span><em>variables: typing.Set[lyra.core.expressions.VariableIdentifier], precursory: lyra.abstract_domains.assumption.assumption_domain.InputMixin = None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/quantity_domain.html#QuantityState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.quantity_domain.QuantityState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lyra.abstract_domains.numerical.html#lyra.abstract_domains.numerical.sign_domain.SignState" title="lyra.abstract_domains.numerical.sign_domain.SignState"><code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.numerical.sign_domain.SignState</span></code></a>, <a class="reference internal" href="#lyra.abstract_domains.assumption.assumption_domain.InputMixin" title="lyra.abstract_domains.assumption.assumption_domain.InputMixin"><code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.assumption.assumption_domain.InputMixin</span></code></a></p>
<p>Quantity assumption analysis state. An element of the quantity assumption abstract domain.</p>
<p>Map from each program variable to the sign representing its value.</p>
<p>When reading input data, the corresponding quantity assumptions
are stored in the class member <code class="docutils literal"><span class="pre">inputs</span></code>, which is a map from each program point
to the list of quantity assumptions on the input data read at that point.</p>
<dl class="method">
<dt id="lyra.abstract_domains.assumption.quantity_domain.QuantityState._assume">
<code class="descname">_assume</code><span class="sig-paren">(</span><em>condition: lyra.core.expressions.Expression</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.numerical.sign_domain.SignState<a class="headerlink" href="#lyra.abstract_domains.assumption.quantity_domain.QuantityState._assume" title="Permalink to this definition">¶</a></dt>
<dd><p>Assume that some condition holds in the current state.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>condition</strong> – expression representing the assumed condition</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current state modified to satisfy the assumption</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.quantity_domain.QuantityState._substitute">
<code class="descname">_substitute</code><span class="sig-paren">(</span><em>left: lyra.core.expressions.Expression</em>, <em>right: lyra.core.expressions.Expression</em><span class="sig-paren">)</span><a class="headerlink" href="#lyra.abstract_domains.assumption.quantity_domain.QuantityState._substitute" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitute an expression to another expression.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>left</strong> – expression to be substituted</li>
<li><strong>right</strong> – expression to substitute</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">current state modified by the substitution</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="lyra.abstract_domains.assumption.quantity_domain.QuantityState.ExpressionRefinement">
<em class="property">class </em><code class="descname">ExpressionRefinement</code><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/quantity_domain.html#QuantityState.ExpressionRefinement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.quantity_domain.QuantityState.ExpressionRefinement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.basis.ExpressionRefinement</span></code></p>
<dl class="method">
<dt id="lyra.abstract_domains.assumption.quantity_domain.QuantityState.ExpressionRefinement.visit_BinaryArithmeticOperation">
<code class="descname">visit_BinaryArithmeticOperation</code><span class="sig-paren">(</span><em>expr</em>, <em>evaluation=None</em>, <em>value=None</em>, <em>state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/quantity_domain.html#QuantityState.ExpressionRefinement.visit_BinaryArithmeticOperation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.quantity_domain.QuantityState.ExpressionRefinement.visit_BinaryArithmeticOperation" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a binary arithmetic operation.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.quantity_domain.QuantityState.ExpressionRefinement.visit_Input">
<code class="descname">visit_Input</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.Input</em>, <em>evaluation=None</em>, <em>value=None</em>, <em>state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/quantity_domain.html#QuantityState.ExpressionRefinement.visit_Input"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.quantity_domain.QuantityState.ExpressionRefinement.visit_Input" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of an input call expression.</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.quantity_domain.QuantityState.replace">
<code class="descname">replace</code><span class="sig-paren">(</span><em>variable: lyra.core.expressions.VariableIdentifier</em>, <em>expression: lyra.core.expressions.Expression</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.quantity_domain.QuantityState<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/quantity_domain.html#QuantityState.replace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.quantity_domain.QuantityState.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace a variable with an expression.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The new variables appearing in the replacing expression are added to the current state.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> – variable to be replaced</li>
<li><strong>expression</strong> – expression replacing the variable</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">current state modified to manifest the replacement</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.quantity_domain.QuantityState.unify">
<code class="descname">unify</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.assumption.quantity_domain.QuantityState</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.quantity_domain.QuantityState<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/quantity_domain.html#QuantityState.unify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.quantity_domain.QuantityState.unify" title="Permalink to this definition">¶</a></dt>
<dd><p>Unification of the environment of the current state
with the environment of another state.</p>
<p>This is needed when new variables are introduced by <code class="docutils literal"><span class="pre">replace()</span></code>
to represent input expressions. The unification should match variables
in the order of the program points on which they depend.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> – state whose environment we want to unify with</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current state modified to reflect the unification</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<span class="target" id="module-lyra.abstract_domains.assumption.range_domain"></span><div class="section" id="range-abstract-domain">
<h3>Range Abstract Domain<a class="headerlink" href="#range-abstract-domain" title="Permalink to this headline">¶</a></h3>
<p>Non-relational abstract domain to be used for <strong>input data assumption analysis</strong>.
The set of possible values of a program variable in a program state
is represented by a value range.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body">Caterina Urban and Madelin Schumacher</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="lyra.abstract_domains.assumption.range_domain.RangeLattice">
<em class="property">class </em><code class="descclassname">lyra.abstract_domains.assumption.range_domain.</code><code class="descname">RangeLattice</code><span class="sig-paren">(</span><em>lower=-inf</em>, <em>upper=inf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/range_domain.html#RangeLattice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.range_domain.RangeLattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lyra.abstract_domains.numerical.html#lyra.abstract_domains.numerical.interval_domain.IntervalLattice" title="lyra.abstract_domains.numerical.interval_domain.IntervalLattice"><code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.numerical.interval_domain.IntervalLattice</span></code></a>, <a class="reference internal" href="#lyra.abstract_domains.assumption.assumption_domain.JSONMixin" title="lyra.abstract_domains.assumption.assumption_domain.JSONMixin"><code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.assumption.assumption_domain.JSONMixin</span></code></a></p>
<p>Range lattice. The bottom range represents an empty set of values.</p>
<img alt="_images/interval.jpg" src="_images/interval.jpg" />
<p>The default abstraction is the unbounded range <code class="docutils literal"><span class="pre">[-oo,</span> <span class="pre">+oo]</span></code>.</p>
<dl class="method">
<dt id="lyra.abstract_domains.assumption.range_domain.RangeLattice._less_equal">
<code class="descname">_less_equal</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.numerical.interval_domain.IntervalLattice</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#lyra.abstract_domains.assumption.range_domain.RangeLattice._less_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Partial order between default lattice elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> – other lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">whether the current lattice element is less than or equal to the other element</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal"><span class="pre">[a,</span> <span class="pre">b]</span> <span class="pre">⊑</span> <span class="pre">[c,</span> <span class="pre">d]</span></code> if and only if <code class="docutils literal"><span class="pre">c</span> <span class="pre">&lt;=</span> <span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span> <span class="pre">&lt;=</span> <span class="pre">d</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.range_domain.RangeLattice._meet">
<code class="descname">_meet</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.numerical.interval_domain.IntervalLattice</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.numerical.interval_domain.IntervalLattice<a class="headerlink" href="#lyra.abstract_domains.assumption.range_domain.RangeLattice._meet" title="Permalink to this definition">¶</a></dt>
<dd><p>Greatest lower bound between default lattice elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> – other lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to be the greatest lower bound</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal"><span class="pre">[a,</span> <span class="pre">b]</span> <span class="pre">⊓</span> <span class="pre">[c,</span> <span class="pre">d]</span> <span class="pre">=</span> <span class="pre">[max(a,c),</span> <span class="pre">min(b,d)]</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.range_domain.RangeLattice._join">
<code class="descname">_join</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.numerical.interval_domain.IntervalLattice</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.numerical.interval_domain.IntervalLattice<a class="headerlink" href="#lyra.abstract_domains.assumption.range_domain.RangeLattice._join" title="Permalink to this definition">¶</a></dt>
<dd><p>Least upper bound between default lattice elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> – other lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to be the least upper bound</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal"><span class="pre">[a,</span> <span class="pre">b]</span> <span class="pre">⊔</span> <span class="pre">[c,</span> <span class="pre">d]</span> <span class="pre">=</span> <span class="pre">[min(a,c),</span> <span class="pre">max(b,d)]</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.range_domain.RangeLattice._widening">
<code class="descname">_widening</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.numerical.interval_domain.IntervalLattice</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.numerical.interval_domain.IntervalLattice<a class="headerlink" href="#lyra.abstract_domains.assumption.range_domain.RangeLattice._widening" title="Permalink to this definition">¶</a></dt>
<dd><p>Widening between default lattice elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> – other lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to be the widening</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal"><span class="pre">[a,</span> <span class="pre">b]</span> <span class="pre">▽</span> <span class="pre">[c,</span> <span class="pre">d]</span> <span class="pre">=</span> <span class="pre">[(c</span> <span class="pre">&lt;</span> <span class="pre">a</span> <span class="pre">?</span> <span class="pre">-oo</span> <span class="pre">:</span> <span class="pre">a),</span> <span class="pre">(b</span> <span class="pre">&lt;</span> <span class="pre">d</span> <span class="pre">?</span> <span class="pre">+oo</span> <span class="pre">:</span> <span class="pre">b)]</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.range_domain.RangeLattice._neg">
<code class="descname">_neg</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.numerical.interval_domain.IntervalLattice<a class="headerlink" href="#lyra.abstract_domains.assumption.range_domain.RangeLattice._neg" title="Permalink to this definition">¶</a></dt>
<dd><p>Negation of a default lattice elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to be its negation</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal"><span class="pre">-</span> <span class="pre">[a,</span> <span class="pre">b]</span> <span class="pre">=</span> <span class="pre">[-b,</span> <span class="pre">-a]</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.range_domain.RangeLattice._add">
<code class="descname">_add</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.numerical.interval_domain.IntervalLattice</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.numerical.interval_domain.IntervalLattice<a class="headerlink" href="#lyra.abstract_domains.assumption.range_domain.RangeLattice._add" title="Permalink to this definition">¶</a></dt>
<dd><p>Addition between two default lattice elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> – other lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to be the sum</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal"><span class="pre">[a,</span> <span class="pre">b]</span> <span class="pre">+</span> <span class="pre">[c,</span> <span class="pre">d]</span> <span class="pre">=</span> <span class="pre">[a</span> <span class="pre">+</span> <span class="pre">c,</span> <span class="pre">b</span> <span class="pre">+</span> <span class="pre">d]</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.range_domain.RangeLattice._sub">
<code class="descname">_sub</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.numerical.interval_domain.IntervalLattice</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.numerical.interval_domain.IntervalLattice<a class="headerlink" href="#lyra.abstract_domains.assumption.range_domain.RangeLattice._sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtraction between two default lattice elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> – other lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to be the difference</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal"><span class="pre">[a,</span> <span class="pre">b]</span> <span class="pre">-</span> <span class="pre">[c,</span> <span class="pre">d]</span> <span class="pre">=</span> <span class="pre">[a</span> <span class="pre">-</span> <span class="pre">d,</span> <span class="pre">b</span> <span class="pre">-</span> <span class="pre">c]</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.range_domain.RangeLattice._mult">
<code class="descname">_mult</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.numerical.interval_domain.IntervalLattice</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.numerical.interval_domain.IntervalLattice<a class="headerlink" href="#lyra.abstract_domains.assumption.range_domain.RangeLattice._mult" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplication between two default lattice elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> – other lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to be the product</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal"><span class="pre">[a,</span> <span class="pre">b]</span> <span class="pre">*</span> <span class="pre">[c,</span> <span class="pre">d]</span> <span class="pre">=</span> <span class="pre">[min(a*c,</span> <span class="pre">a*d,</span> <span class="pre">b*c,</span> <span class="pre">b*d),</span> <span class="pre">max(a*c,</span> <span class="pre">a*d,</span> <span class="pre">b*c,</span> <span class="pre">b*d)]</span></code>.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="lyra.abstract_domains.assumption.range_domain.RangeLattice.from_json">
<em class="property">static </em><code class="descname">from_json</code><span class="sig-paren">(</span><em>json: str</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.JSONMixin<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/range_domain.html#RangeLattice.from_json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.range_domain.RangeLattice.from_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstruct a lattice element from its JSON format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>json</strong> – JSON format of a lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">reconstructed lattice element from its JSON format</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.range_domain.RangeLattice.to_json">
<code class="descname">to_json</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/range_domain.html#RangeLattice.to_json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.range_domain.RangeLattice.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the current lattice element to JSON format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">JSON format of the current lattice element</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lyra.abstract_domains.assumption.range_domain.RangeState">
<em class="property">class </em><code class="descclassname">lyra.abstract_domains.assumption.range_domain.</code><code class="descname">RangeState</code><span class="sig-paren">(</span><em>variables: typing.Set[lyra.core.expressions.VariableIdentifier], precursory: lyra.abstract_domains.assumption.assumption_domain.InputMixin = None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/range_domain.html#RangeState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.range_domain.RangeState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lyra.abstract_domains.numerical.html#lyra.abstract_domains.numerical.interval_domain.IntervalState" title="lyra.abstract_domains.numerical.interval_domain.IntervalState"><code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.numerical.interval_domain.IntervalState</span></code></a>, <a class="reference internal" href="#lyra.abstract_domains.assumption.assumption_domain.InputMixin" title="lyra.abstract_domains.assumption.assumption_domain.InputMixin"><code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.assumption.assumption_domain.InputMixin</span></code></a></p>
<p>Range assumption analysis state. An element of the range assumption abstract domain.</p>
<p>Map from each program variable to the value range representing its value.
The value of all program variables is represented by the unbounded range by default.</p>
<p>When reading input data, the corresponding range assumptions
are stored in the class member <code class="docutils literal"><span class="pre">inputs</span></code>, which is a map from each program point
to the list of range assumptions on the input data read at that point.</p>
<dl class="method">
<dt id="lyra.abstract_domains.assumption.range_domain.RangeState._assume">
<code class="descname">_assume</code><span class="sig-paren">(</span><em>condition: lyra.core.expressions.Expression</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.numerical.interval_domain.IntervalState<a class="headerlink" href="#lyra.abstract_domains.assumption.range_domain.RangeState._assume" title="Permalink to this definition">¶</a></dt>
<dd><p>Assume that some condition holds in the current state.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>condition</strong> – expression representing the assumed condition</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current state modified to satisfy the assumption</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.range_domain.RangeState._substitute">
<code class="descname">_substitute</code><span class="sig-paren">(</span><em>left: lyra.core.expressions.Expression</em>, <em>right: lyra.core.expressions.Expression</em><span class="sig-paren">)</span><a class="headerlink" href="#lyra.abstract_domains.assumption.range_domain.RangeState._substitute" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitute an expression to another expression.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>left</strong> – expression to be substituted</li>
<li><strong>right</strong> – expression to substitute</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">current state modified by the substitution</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="lyra.abstract_domains.assumption.range_domain.RangeState.ExpressionRefinement">
<em class="property">class </em><code class="descname">ExpressionRefinement</code><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/range_domain.html#RangeState.ExpressionRefinement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.range_domain.RangeState.ExpressionRefinement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.basis.ExpressionRefinement</span></code></p>
<dl class="method">
<dt id="lyra.abstract_domains.assumption.range_domain.RangeState.ExpressionRefinement.visit_Input">
<code class="descname">visit_Input</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.Input</em>, <em>evaluation=None</em>, <em>value=None</em>, <em>state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/range_domain.html#RangeState.ExpressionRefinement.visit_Input"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.range_domain.RangeState.ExpressionRefinement.visit_Input" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of an input call expression.</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.range_domain.RangeState.replace">
<code class="descname">replace</code><span class="sig-paren">(</span><em>variable: lyra.core.expressions.VariableIdentifier</em>, <em>expression: lyra.core.expressions.Expression</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.range_domain.RangeState<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/range_domain.html#RangeState.replace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.range_domain.RangeState.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace a variable with an expression.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The new variables appearing in the replacing expression are added to the current state.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> – variable to be replaced</li>
<li><strong>expression</strong> – expression replacing the variable</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">current state modified to manifest the replacement</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.range_domain.RangeState.unify">
<code class="descname">unify</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.assumption.range_domain.RangeState</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.range_domain.RangeState<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/range_domain.html#RangeState.unify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.range_domain.RangeState.unify" title="Permalink to this definition">¶</a></dt>
<dd><p>Unification of the environment of the current state
with the environment of another state.</p>
<p>This is needed when new variables are introduced by <code class="docutils literal"><span class="pre">replace()</span></code>
to represent input expressions. The unification should match variables
in the order of the program points on which they depend.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> – state whose environment we want to unify with</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current state modified to reflect the unification</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<span class="target" id="module-lyra.abstract_domains.assumption.type_domain"></span><div class="section" id="type-abstract-domain">
<h3>Type Abstract Domain<a class="headerlink" href="#type-abstract-domain" title="Permalink to this headline">¶</a></h3>
<p>Non-relational abstract domain to be used for <strong>input data assumption analysis</strong>.
The set of possible values of a program variable in a state is represented as a type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body">Caterina Urban and Madelin Schumacher</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeLattice">
<em class="property">class </em><code class="descclassname">lyra.abstract_domains.assumption.type_domain.</code><code class="descname">TypeLattice</code><span class="sig-paren">(</span><em>type_status: lyra.abstract_domains.assumption.type_domain.TypeLattice.Status = &lt;Status.String: 3&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeLattice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeLattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lyra.abstract_domains.html#lyra.abstract_domains.lattice.BottomMixin" title="lyra.abstract_domains.lattice.BottomMixin"><code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.lattice.BottomMixin</span></code></a>, <a class="reference internal" href="lyra.abstract_domains.html#lyra.abstract_domains.lattice.ArithmeticMixin" title="lyra.abstract_domains.lattice.ArithmeticMixin"><code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.lattice.ArithmeticMixin</span></code></a>, <a class="reference internal" href="#lyra.abstract_domains.assumption.assumption_domain.JSONMixin" title="lyra.abstract_domains.assumption.assumption_domain.JSONMixin"><code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.assumption.assumption_domain.JSONMixin</span></code></a></p>
<p>Type Lattice:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>String
  |
Float
  |
Integer
  |
Boolean
  |
  ⊥
</pre></div>
</div>
<p>The default lattice element is <code class="docutils literal"><span class="pre">String</span></code>.</p>
<p>Let S be the set of all possible strings. We define F ⊆ S, I ⊆ F, B ⊆ I to be the sets of
all possible strings that can be interpreted as floating-point numbers
(i.e., F = { 2.35, …, 9.345, …}), integers (i.e., I = { -3, …, 15, …}),
and booleans (i.e., B = { 0, 1 }), respectively.
The concretization function Ɣ: TypeLattice -&gt; 𝒫(S) is defined as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>Ɣ(String) = S
Ɣ(Float) = F
Ɣ(Integer) = I
Ɣ(Boolean) = B
Ɣ(⊥) = ∅
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>One might want to have Ɣ(Boolean) = { ‘True’, ‘False’ }. This, however, would yield
the following different lattice structure:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>       String
     /        \
    /        Float
Boolean        |
     \      Integer
      \      /
          ⊥
</pre></div>
</div>
<p class="last">which is not compatible with subtyping between boolean and integer types in Python.</p>
</div>
<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeLattice._less_equal">
<code class="descname">_less_equal</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.assumption.type_domain.TypeLattice</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeLattice._less_equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeLattice._less_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Partial order between default lattice elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> – other lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">whether the current lattice element is less than or equal to the other element</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeLattice._meet">
<code class="descname">_meet</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.assumption.type_domain.TypeLattice</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeLattice._meet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeLattice._meet" title="Permalink to this definition">¶</a></dt>
<dd><p>Greatest lower bound between default lattice elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> – other lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to be the greatest lower bound</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeLattice._join">
<code class="descname">_join</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.assumption.type_domain.TypeLattice</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.type_domain.TypeLattice<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeLattice._join"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeLattice._join" title="Permalink to this definition">¶</a></dt>
<dd><p>Least upper bound between default lattice elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> – other lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to be the least upper bound</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeLattice._widening">
<code class="descname">_widening</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.assumption.type_domain.TypeLattice</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeLattice._widening"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeLattice._widening" title="Permalink to this definition">¶</a></dt>
<dd><p>Widening between default lattice elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> – other lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to be the widening</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeLattice.Status">
<em class="property">class </em><code class="descname">Status</code><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeLattice.Status"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeLattice.Status" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">enum.IntEnum</span></code></p>
<p>Type status.</p>
<p>The current lattice element can be:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">String</span></code>: String type</li>
<li><code class="docutils literal"><span class="pre">Float</span></code>: Float type</li>
<li><code class="docutils literal"><span class="pre">Integer</span></code> Integer type</li>
<li><code class="docutils literal"><span class="pre">Boolean</span></code>: Boolean type</li>
</ul>
<dl class="attribute">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeLattice.Status.Boolean">
<code class="descname">Boolean</code><em class="property"> = 0</em><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeLattice.Status.Boolean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeLattice.Status.Float">
<code class="descname">Float</code><em class="property"> = 2</em><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeLattice.Status.Float" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeLattice.Status.Integer">
<code class="descname">Integer</code><em class="property"> = 1</em><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeLattice.Status.Integer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeLattice.Status.String">
<code class="descname">String</code><em class="property"> = 3</em><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeLattice.Status.String" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeLattice.boolean">
<code class="descname">boolean</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.type_domain.TypeLattice<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeLattice.boolean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeLattice.boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Integer lattice element.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to be the boolean lattice element</td>
</tr>
</tbody>
</table>
<p>The integer lattice element is <code class="docutils literal"><span class="pre">Boolean</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeLattice.element">
<code class="descname">element</code><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeLattice.element" title="Permalink to this definition">¶</a></dt>
<dd><p>Current lattice element.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the current lattice element if the type is not bottom, <code class="docutils literal"><span class="pre">None</span></code> otherwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeLattice.float">
<code class="descname">float</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.type_domain.TypeLattice<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeLattice.float"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeLattice.float" title="Permalink to this definition">¶</a></dt>
<dd><p>Float lattice element.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to be the float lattice element</td>
</tr>
</tbody>
</table>
<p>The float lattice element is <code class="docutils literal"><span class="pre">Float</span></code>.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeLattice.from_json">
<em class="property">static </em><code class="descname">from_json</code><span class="sig-paren">(</span><em>json: str</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.assumption_domain.JSONMixin<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeLattice.from_json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeLattice.from_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstruct a lattice element from its JSON format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>json</strong> – JSON format of a lattice element</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">reconstructed lattice element from its JSON format</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeLattice.from_lyra_type">
<em class="property">classmethod </em><code class="descname">from_lyra_type</code><span class="sig-paren">(</span><em>lyra_type: lyra.core.types.LyraType</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeLattice.from_lyra_type"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeLattice.from_lyra_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeLattice.integer">
<code class="descname">integer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.type_domain.TypeLattice<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeLattice.integer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeLattice.integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Integer lattice element.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to be the integer lattice element</td>
</tr>
</tbody>
</table>
<p>The integer lattice element is <code class="docutils literal"><span class="pre">Integer</span></code></p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeLattice.is_boolean">
<code class="descname">is_boolean</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeLattice.is_boolean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeLattice.is_boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the lattice element is boolean.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">whether the lattice element is <code class="docutils literal"><span class="pre">Boolean</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeLattice.is_float">
<code class="descname">is_float</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeLattice.is_float"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeLattice.is_float" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the lattice element is float.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">whether the lattice element is <code class="docutils literal"><span class="pre">Float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeLattice.is_integer">
<code class="descname">is_integer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeLattice.is_integer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeLattice.is_integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the lattice element is integer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">whether the lattice element is <code class="docutils literal"><span class="pre">Integer</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeLattice.is_top">
<code class="descname">is_top</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeLattice.is_top"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeLattice.is_top" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the lattice element is top.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">whether the lattice element is top</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeLattice.to_json">
<code class="descname">to_json</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeLattice.to_json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeLattice.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the current lattice element to JSON format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">JSON format of the current lattice element</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeLattice.top">
<code class="descname">top</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.type_domain.TypeLattice<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeLattice.top"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeLattice.top" title="Permalink to this definition">¶</a></dt>
<dd><p>Top lattice element.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">current lattice element modified to be the top lattice element</td>
</tr>
</tbody>
</table>
<p>The top lattice element is <code class="docutils literal"><span class="pre">String</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState">
<em class="property">class </em><code class="descclassname">lyra.abstract_domains.assumption.type_domain.</code><code class="descname">TypeState</code><span class="sig-paren">(</span><em>variables: typing.Set[lyra.core.expressions.VariableIdentifier], precursory: lyra.abstract_domains.state.State = None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lyra.abstract_domains.html#lyra.abstract_domains.store.Store" title="lyra.abstract_domains.store.Store"><code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.store.Store</span></code></a>, <a class="reference internal" href="#lyra.abstract_domains.assumption.assumption_domain.InputMixin" title="lyra.abstract_domains.assumption.assumption_domain.InputMixin"><code class="xref py py-class docutils literal"><span class="pre">lyra.abstract_domains.assumption.assumption_domain.InputMixin</span></code></a></p>
<p>Type assumption analysis state. An element of the type assumption abstract domain.</p>
<p>Map from each program variable to the type representing its value.
The value of all program variables is represented by their Lyra type by default.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This means that, for any map m: VariableIdentifier -&gt; TypeLattice and variable x,
we should always have m(x) ≤ TypeLattice.from_lyra_type(x.typ)</p>
</div>
<p>When reading input data, the corresponding type assumptions
are stored in the class member <code class="docutils literal"><span class="pre">inputs</span></code>, which is a map from each program point
to the list of type assumptions on the inputs read at that point.</p>
<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState._assume">
<code class="descname">_assume</code><span class="sig-paren">(</span><em>condition: lyra.core.expressions.Expression</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.type_domain.TypeState<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState._assume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState._assume" title="Permalink to this definition">¶</a></dt>
<dd><p>Assume that some condition holds in the current state.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>condition</strong> – expression representing the assumed condition</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current state modified to satisfy the assumption</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState._substitute">
<code class="descname">_substitute</code><span class="sig-paren">(</span><em>left: lyra.core.expressions.Expression</em>, <em>right: lyra.core.expressions.Expression</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.type_domain.TypeState<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState._substitute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState._substitute" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitute an expression to another expression.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>left</strong> – expression to be substituted</li>
<li><strong>right</strong> – expression to substitute</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">current state modified by the substitution</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement">
<em class="property">class </em><code class="descname">ArithmeticExpressionRefinement</code><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ArithmeticExpressionRefinement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lyra.core.html#lyra.core.expressions.ExpressionVisitor" title="lyra.core.expressions.ExpressionVisitor"><code class="xref py py-class docutils literal"><span class="pre">lyra.core.expressions.ExpressionVisitor</span></code></a></p>
<p>Visitor that:</p>
<ol class="arabic simple">
<li>refines the value of an evaluated arithmetic expression based on a given interval; and</li>
<li>modifies the current state based on the refined value of the arithmetic expression.</li>
</ol>
<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit">
<code class="descname">visit</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.Expression</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ArithmeticExpressionRefinement.visit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of an evaluated expression.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_AttributeReference">
<code class="descname">visit_AttributeReference</code><span class="sig-paren">(</span><em>expr</em>, <em>evaluation=None</em>, <em>value=None</em>, <em>state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ArithmeticExpressionRefinement.visit_AttributeReference"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_AttributeReference" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of an attribute reference.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_BinaryArithmeticOperation">
<code class="descname">visit_BinaryArithmeticOperation</code><span class="sig-paren">(</span><em>expr</em>, <em>evaluation=None</em>, <em>value=None</em>, <em>state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ArithmeticExpressionRefinement.visit_BinaryArithmeticOperation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_BinaryArithmeticOperation" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a binary arithmetic operation.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_BinaryBooleanOperation">
<code class="descname">visit_BinaryBooleanOperation</code><span class="sig-paren">(</span><em>expr</em>, <em>evaluation=None</em>, <em>value=None</em>, <em>state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ArithmeticExpressionRefinement.visit_BinaryBooleanOperation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_BinaryBooleanOperation" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a binary boolean operation.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_BinaryComparisonOperation">
<code class="descname">visit_BinaryComparisonOperation</code><span class="sig-paren">(</span><em>expr</em>, <em>evaluation=None</em>, <em>value=None</em>, <em>state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ArithmeticExpressionRefinement.visit_BinaryComparisonOperation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_BinaryComparisonOperation" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a binary comparison operation.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_BinarySequenceOperation">
<code class="descname">visit_BinarySequenceOperation</code><span class="sig-paren">(</span><em>expr</em>, <em>evaluation=None</em>, <em>value=None</em>, <em>state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ArithmeticExpressionRefinement.visit_BinarySequenceOperation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_BinarySequenceOperation" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a binary sequence operation.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_DictDisplay">
<code class="descname">visit_DictDisplay</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.DictDisplay</em>, <em>state=None</em>, <em>evaluation=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ArithmeticExpressionRefinement.visit_DictDisplay"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_DictDisplay" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of dictionary display.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_Input">
<code class="descname">visit_Input</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.Input</em>, <em>evaluation=None</em>, <em>value=None</em>, <em>state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ArithmeticExpressionRefinement.visit_Input"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_Input" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of an input call expression.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_LengthIdentifier">
<code class="descname">visit_LengthIdentifier</code><span class="sig-paren">(</span><em>expr</em>, <em>evaluation=None</em>, <em>value=None</em>, <em>state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ArithmeticExpressionRefinement.visit_LengthIdentifier"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_LengthIdentifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a sequence or collection length.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_ListDisplay">
<code class="descname">visit_ListDisplay</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.ListDisplay</em>, <em>evaluation=None</em>, <em>value=None</em>, <em>state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ArithmeticExpressionRefinement.visit_ListDisplay"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_ListDisplay" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a list display.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_Literal">
<code class="descname">visit_Literal</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.Literal</em>, <em>evaluation=None</em>, <em>value=None</em>, <em>state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ArithmeticExpressionRefinement.visit_Literal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_Literal" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a literal expression.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_Range">
<code class="descname">visit_Range</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.Range</em>, <em>state=None</em>, <em>evaluation=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ArithmeticExpressionRefinement.visit_Range"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_Range" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a range call expression.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_SetDisplay">
<code class="descname">visit_SetDisplay</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.SetDisplay</em>, <em>state=None</em>, <em>evaluation=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ArithmeticExpressionRefinement.visit_SetDisplay"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_SetDisplay" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a set display.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_Slicing">
<code class="descname">visit_Slicing</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.Slicing</em>, <em>evaluation=None</em>, <em>value=None</em>, <em>state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ArithmeticExpressionRefinement.visit_Slicing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_Slicing" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a slicing expression.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_Subscription">
<code class="descname">visit_Subscription</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.Subscription</em>, <em>evaluation=None</em>, <em>value=None</em>, <em>state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ArithmeticExpressionRefinement.visit_Subscription"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_Subscription" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a subscription expression.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_TupleDisplay">
<code class="descname">visit_TupleDisplay</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.TupleDisplay</em>, <em>state=None</em>, <em>evaluation=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ArithmeticExpressionRefinement.visit_TupleDisplay"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_TupleDisplay" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a tuple display.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_UnaryArithmeticOperation">
<code class="descname">visit_UnaryArithmeticOperation</code><span class="sig-paren">(</span><em>expr</em>, <em>evaluation=None</em>, <em>value=None</em>, <em>state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ArithmeticExpressionRefinement.visit_UnaryArithmeticOperation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_UnaryArithmeticOperation" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a unary arithmetic operation.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_UnaryBooleanOperation">
<code class="descname">visit_UnaryBooleanOperation</code><span class="sig-paren">(</span><em>expr</em>, <em>evaluation=None</em>, <em>value=None</em>, <em>state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ArithmeticExpressionRefinement.visit_UnaryBooleanOperation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_UnaryBooleanOperation" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a unary boolean operation.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_VariableIdentifier">
<code class="descname">visit_VariableIdentifier</code><span class="sig-paren">(</span><em>expr</em>, <em>evaluation=None</em>, <em>value=None</em>, <em>state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ArithmeticExpressionRefinement.visit_VariableIdentifier"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ArithmeticExpressionRefinement.visit_VariableIdentifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a variable identifier.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation">
<em class="property">class </em><code class="descname">ExpressionEvaluation</code><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ExpressionEvaluation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lyra.core.html#lyra.core.expressions.ExpressionVisitor" title="lyra.core.expressions.ExpressionVisitor"><code class="xref py py-class docutils literal"><span class="pre">lyra.core.expressions.ExpressionVisitor</span></code></a></p>
<p>Visitor that performs the evaluation of an expression in the type lattice.</p>
<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_AttributeReference">
<code class="descname">visit_AttributeReference</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.AttributeReference</em>, <em>state=None</em>, <em>evaluation=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ExpressionEvaluation.visit_AttributeReference"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_AttributeReference" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of an attribute reference.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_BinaryArithmeticOperation">
<code class="descname">visit_BinaryArithmeticOperation</code><span class="sig-paren">(</span><em>expr</em>, <em>state=None</em>, <em>evaluation=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ExpressionEvaluation.visit_BinaryArithmeticOperation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_BinaryArithmeticOperation" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a binary arithmetic operation.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_BinaryBooleanOperation">
<code class="descname">visit_BinaryBooleanOperation</code><span class="sig-paren">(</span><em>expr</em>, <em>state=None</em>, <em>evaluation=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ExpressionEvaluation.visit_BinaryBooleanOperation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_BinaryBooleanOperation" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a binary boolean operation.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_BinaryComparisonOperation">
<code class="descname">visit_BinaryComparisonOperation</code><span class="sig-paren">(</span><em>expr</em>, <em>state=None</em>, <em>evaluation=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ExpressionEvaluation.visit_BinaryComparisonOperation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_BinaryComparisonOperation" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a binary comparison operation.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_BinarySequenceOperation">
<code class="descname">visit_BinarySequenceOperation</code><span class="sig-paren">(</span><em>expr</em>, <em>state=None</em>, <em>evaluation=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ExpressionEvaluation.visit_BinarySequenceOperation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_BinarySequenceOperation" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a binary sequence operation.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_DictDisplay">
<code class="descname">visit_DictDisplay</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.DictDisplay</em>, <em>state=None</em>, <em>evaluation=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ExpressionEvaluation.visit_DictDisplay"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_DictDisplay" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of dictionary display.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_Input">
<code class="descname">visit_Input</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.Input</em>, <em>state=None</em>, <em>evaluation=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ExpressionEvaluation.visit_Input"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_Input" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of an input call expression.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_LengthIdentifier">
<code class="descname">visit_LengthIdentifier</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.LengthIdentifier</em>, <em>state=None</em>, <em>evaluation=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ExpressionEvaluation.visit_LengthIdentifier"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_LengthIdentifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a sequence or collection length.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_ListDisplay">
<code class="descname">visit_ListDisplay</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.ListDisplay</em>, <em>state=None</em>, <em>evaluation=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ExpressionEvaluation.visit_ListDisplay"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_ListDisplay" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a list display.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_Literal">
<code class="descname">visit_Literal</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.Literal</em>, <em>state=None</em>, <em>evaluation=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ExpressionEvaluation.visit_Literal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_Literal" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a literal expression.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_Range">
<code class="descname">visit_Range</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.Range</em>, <em>state=None</em>, <em>evaluation=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ExpressionEvaluation.visit_Range"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_Range" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a range call expression.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_SetDisplay">
<code class="descname">visit_SetDisplay</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.SetDisplay</em>, <em>state=None</em>, <em>evaluation=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ExpressionEvaluation.visit_SetDisplay"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_SetDisplay" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a set display.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_Slicing">
<code class="descname">visit_Slicing</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.Slicing</em>, <em>state=None</em>, <em>evaluation=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ExpressionEvaluation.visit_Slicing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_Slicing" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a slicing expression.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_Subscription">
<code class="descname">visit_Subscription</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.Subscription</em>, <em>state=None</em>, <em>evaluation=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ExpressionEvaluation.visit_Subscription"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_Subscription" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a subscription expression.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_TupleDisplay">
<code class="descname">visit_TupleDisplay</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.TupleDisplay</em>, <em>state=None</em>, <em>evaluation=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ExpressionEvaluation.visit_TupleDisplay"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_TupleDisplay" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a tuple display.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_UnaryArithmeticOperation">
<code class="descname">visit_UnaryArithmeticOperation</code><span class="sig-paren">(</span><em>expr</em>, <em>state=None</em>, <em>evaluation=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ExpressionEvaluation.visit_UnaryArithmeticOperation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_UnaryArithmeticOperation" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a unary arithmetic operation.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_UnaryBooleanOperation">
<code class="descname">visit_UnaryBooleanOperation</code><span class="sig-paren">(</span><em>expr</em>, <em>state=None</em>, <em>evaluation=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ExpressionEvaluation.visit_UnaryBooleanOperation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_UnaryBooleanOperation" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a unary boolean operation.</p>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_VariableIdentifier">
<code class="descname">visit_VariableIdentifier</code><span class="sig-paren">(</span><em>expr: lyra.core.expressions.VariableIdentifier</em>, <em>state=None</em>, <em>evaluation=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.ExpressionEvaluation.visit_VariableIdentifier"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.ExpressionEvaluation.visit_VariableIdentifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit of a variable identifier.</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.enter_if">
<code class="descname">enter_if</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.type_domain.TypeState<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.enter_if"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.enter_if" title="Permalink to this definition">¶</a></dt>
<dd><p>Enter a conditional if statement.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">current state modified to enter a conditional if statement</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.enter_loop">
<code class="descname">enter_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.type_domain.TypeState<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.enter_loop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.enter_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Enter a loop.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">current state modified to enter a loop</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.exit_if">
<code class="descname">exit_if</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.type_domain.TypeState<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.exit_if"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.exit_if" title="Permalink to this definition">¶</a></dt>
<dd><p>Exit a conditional if statement.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">current state modified to enter a conditional if statement</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.exit_loop">
<code class="descname">exit_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.type_domain.TypeState<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.exit_loop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.exit_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Exit a loop.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current state could also be bottom or top.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">current state modified to exit a loop</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.replace">
<code class="descname">replace</code><span class="sig-paren">(</span><em>variable: lyra.core.expressions.VariableIdentifier</em>, <em>expression: lyra.core.expressions.Expression</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.type_domain.TypeState<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.replace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace a variable with an expression.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The new variables appearing in the replacing expression are added to the current state.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> – variable to be replaced</li>
<li><strong>expression</strong> – expression replacing the variable</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">current state modified to manifest the replacement</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lyra.abstract_domains.assumption.type_domain.TypeState.unify">
<code class="descname">unify</code><span class="sig-paren">(</span><em>other: lyra.abstract_domains.assumption.type_domain.TypeState</em><span class="sig-paren">)</span> &#x2192; lyra.abstract_domains.assumption.type_domain.TypeState<a class="reference internal" href="_modules/lyra/abstract_domains/assumption/type_domain.html#TypeState.unify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lyra.abstract_domains.assumption.type_domain.TypeState.unify" title="Permalink to this definition">¶</a></dt>
<dd><p>Unification of the environment of the current state
with the environment of another state.</p>
<p>This is needed when new variables are introduced by <code class="docutils literal"><span class="pre">replace()</span></code>
to represent input expressions. The unification should match variables
in the order of the program points on which they depend.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> – state whose environment we want to unify with</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">current state modified to reflect the unification</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="lyra.abstract_domains.liveness.html" class="btn btn-neutral float-right" title="lyra.abstract_domains.liveness package" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="lyra.abstract_domains.html" class="btn btn-neutral" title="lyra.abstract_domains package" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Caterina Urban.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>