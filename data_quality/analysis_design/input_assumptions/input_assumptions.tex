\documentclass[11pt]{article}
\usepackage[a4paper, portrait, margin=1in]{geometry}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{mathtools}
\usepackage{color}
\usepackage[dvipsnames]{xcolor}
\usepackage{float}% If comment this, figure moves to Page 2
% Fancy header package for version number
\usepackage[font={small,it}]{caption}

\usepackage{fancyhdr}
%\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\newcommand{\bigcell}[2]{\begin{tabular}{@{}#1@{}}#2\end{tabular}}
 
\lstdefinelanguage{Python2}{
  language     = Python,
  morekeywords = {assert},
}
 
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{white},   
    commentstyle=\color{ForestGreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{black},
    stringstyle=\color{red},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle, language=Python2}

\begin{document}

\title{Input Assumptions}

\maketitle

\pagenumbering{arabic}

\section{Design}

\subsection{New Idea}



\subsection{First Idea}

First idea was to have a list abstraction for the inputs. Every time input() is encountered we add an element to the front of the current .IN element. The problem with this approach is, that the program analysis does an overapproximation whereas for the input list we don't want to do an overapproximation but just keep the current state. A problem then occurs for example if we have a loop gathering calling input and maybe some input() before the loop. The code before the loop will be analyzed before the loop body because of the worklist algorithm. This means that if we for example later realize we don't know how many iterations are done in the input calling loop we need to remove the assumption when analyzing the code before the loop again. 

Furthermore there is a difference in joining if-else and while. In the if-else case we want to do a real join whereas in the while case we want to keep on adding assumptions and ignore the empty assumption list on the else case of the while loop. 

Also if we enter a loop and we already found 4 inputs and then enter a loop we need to make sure that the loop does not think that we need to add 4 elements in every loop iteration.

\subsection{Problem: join with different number of inputs:}

\begin{lstlisting}[numbers=none]

a = int(input())
if a > 10:
    # INPUT = [float, int]
    b = int(input())
else:
    # INPUT = [float]
    b = a + 1
# INPUT = [float]
c = float(input())
# INPUT = []
\end{lstlisting}

correct solution: \verb|if a > 10: [float, int, int], else: [float, int]|

current solution: if we need to join two input-lists with different length we set the Input Assumption to bottom. If we encounter another input() we create a new InputAssumption list and add the current assumption, this way we keep at least information about the first couple of assumptions.

\end{document}






















